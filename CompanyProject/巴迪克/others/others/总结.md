
### 生成谷歌验证码：
https://www.cnblogs.com/lipx9527/p/13933284.html
#### Base32编码：
清理 `secret_key` 是为了确保其符合 Base32 编码的规范，避免在解码过程中出现错误。Base32 编码有严格的字符集要求，只允许特定的字符（A-Z, 2-7 和 =）。如果 `secret_key` 中包含其他无效字符，直接进行解码会引发 `binascii.Error` 异常。

清理 `secret_key` 的原因：

1. **去除无效字符**：
   - 如果 `secret_key` 中包含了非 Base32 字符（如空格、特殊符号等），这些字符会导致解码失败。
   - 使用正则表达式 `re.sub(r'[^A-Z2-7=]', '', secret_key.upper())` 可以将所有非 Base32 字符移除，并将所有字母转换为大写，确保 `secret_key` 符合 Base32 编码的要求。

2. **统一大小写**：
   - Base32 编码是不区分大小写的，但在某些实现中可能对大小写敏感。通过将 `secret_key` 转换为大写，可以避免大小写引起的潜在问题。

3. **提高代码健壮性**：
   - 在实际应用中，`secret_key` 可能来自不同的来源，可能会包含一些意外的字符或格式问题。通过清理 `secret_key`，可以减少因输入数据不规范导致的错误，提高代码的健壮性和可靠性。

示例代码中的清理步骤：

```python
@staticmethod
def clean_secret_key(secret_key):
    """清理 secret_key，去除无效字符"""
    return re.sub(r'[^A-Z2-7=]', '', secret_key.upper())
```


这段代码的作用是：
- 将 `secret_key` 中的所有字符转换为大写。
- 使用正则表达式替换掉所有非 Base32 字符（即不在 `[A-Z2-7=]` 范围内的字符）。

### 总结：
清理 `secret_key` 是一个必要的预处理步骤，它可以确保输入的秘钥符合 Base32 编码的要求，从而避免在后续的解码和计算过程中出现错误。这不仅提高了代码的健壮性，也使得程序更加可靠和易于维护。


## 断言 ##
第二个 #exeStatus 元素包含文本 "Success"
 assert "Success" in page.locator("#exeStatus").nth(1).text_content()

## 细节问题 ##
text=theshy 没有加引号（单引号或者双引号），模糊匹配，对大小写不敏感
text=‘Theshy’ 有引号，精确匹配，对大小写敏感

## 元素定位 
#### 等待元素可见
 setting_sales_button.wait_for(state="visible", timeout=10000)

#### 点击元素失败
- 1.滚动到按钮
setting_sales_button.scroll_into_view_if_needed()

- 2.强制点击按钮
setting_sales_button.click(force=True)

- 3.尝试直接使用 JavaScript 点击按钮
page.evaluate('(button) => button.click()', setting_sales_button.element_handle())


assert 或 if 
expect 方法通常用于检查 Playwright 的定位器对象或页面状态，而不是直接用于字符串比较。

##### 完全匹配文本 // * [text() = "theshy "]
##### 部分匹配文本 // * [contains(text(),“theshy”)]

包含：
page.get_by_role("listitem").filter(has_text="MCPPay-izpocket-wallet").locator("label").click()

#### 等待toast出现并获取内容
try:

    # 定位toast容器（根据实际样式调整选择器）
    toast = page.locator(".jq-toast-single.jq-has-icon")

    # 等待toast可见（最多等5秒）
    toast.wait_for(state="visible", timeout=5000)
    
    # 获取toast内容
    toast_text = toast.inner_text()
    
    # 断言是否包含成功关键词
    if "success" in toast_text.lower():
        print(f"✅ 验证码发送成功 | {toast_text}")
    else:
        print(f"❌ 验证码发送失败 | {toast_text}")
        
    # 也可以使用Playwright的expect断言
    expect(toast).to_contain_text("success")  # 如果失败会抛出异常

except Exception as e:
    print("⏳ 未检测到toast弹出:", str(e))
    page.screenshot(path="debug_toast_missing.png")  # 保存截图用于调试


# 更精准的等待方式
with page.expect_response("**/send-verification-code") as response_info:
    page.get_by_role("button", name="Send the verification code").click()
response = response_info.value
if response.ok:
    print("API请求成功")
