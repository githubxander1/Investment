//+------------------------------------------------------------------+
//|                                                     ExpWPRBB.mq5 |
//|                                  Copyright 2025, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"

//+------------------------------------------------------------------+
//| Включаемые файлы                                                 |
//+------------------------------------------------------------------+
#include <Trade\Trade.mqh>
#include <Arrays\ArrayLong.mqh>

//+------------------------------------------------------------------+
//| Перечисления                                                     |
//+------------------------------------------------------------------+
//--- Типы сигналов
enum ENUM_SIGNAL_TYPE
  {
   SIGNAL_TYPE_NONE,                                                 // Нет сигнала
   SIGNAL_TYPE_LONG,                                                 // Сигнал на покупку
   SIGNAL_TYPE_SHORT,                                                // Сигнал на покупку
  };

//--- Структура позиций
struct SData
  {
   CArrayLong  list_tickets;                                         // Список тикетов открытых позиций
   double      total_volume;                                         // Общий объём открытых позиций
  };

//--- Структура данных позиций по типам
struct SDataPositions
  {
   SData       Buy;                                                  // Данные позиций Buy
   SData       Sell;                                                 // Данные позиций Sell
  }
Data;
//+------------------------------------------------------------------+
  
  
//+------------------------------------------------------------------+
//| Макроподстановки                                                 |
//+------------------------------------------------------------------+
#define  DATA_COUNT        3                                         // Количество получаемых данных от индикаторов (3 и более)
#define  ENV_ATTEMPTS      3                                         // Количество попыток ожидания получения окружения
#define  ENV_WAIT_ATTEMPT  1000                                      // Количество миллисекунд ожидания обновления окружения
#define  SPREAD_MLTP       3                                         // Множитель спреда для дистанции стоп-приказов

//+------------------------------------------------------------------+
//| Входные параметры                                                |
//+------------------------------------------------------------------+
//--- WPR
input int                  InpPeriodWPR      =  32;                  /* WPR calculation period */                             // Период расчёта WPR
input double               InpOverboughtWPR  = -20;                  /* WPR Overbought Level */                               // Уровень перекупленности WPR
input double               InpOversoldWPR    = -80;                  /* WPR Oversold Level */                                 // Уровень перепроданности WPR
//--- BB
input int                  InpPeriodBB       =  58;                  /* BB calculation period */                              // Период расчёта BB
input double               InpDeviationBB    =  2.0;                 /* BB deviations */                                      // Отклонения BB
input int                  InpShiftBB        =  0;                   /* BB shift */                                           // Сдвиг BB
input ENUM_APPLIED_PRICE   InpPriceBB        =  PRICE_CLOSE;         /* BB applied price */                                   // Цена расчёта BB
//--- ATR
input int                  InpPeriodATR      =  64;                  /* ATR calculation period */                             // Период расчёта ATR
//--- Торговля
input bool                 InpSignalsOnly    =  false;               /* Don't trade, just mark signals */                     // Не торговать, только ставить метки сигналов
input double               InpVolume         =  0.1;                 /* Position volume */                                    // Объем позиции
sinput ulong               InpDeviation      =  10;                  /* Slippage (in points) */                               // Проскальзывание (в пунктах)
sinput ulong               InpMagic          =  123456;              /* Magic number */                                       // Магик
input int                  InpStopLoss       =  -1;                  /* Stop loss (in points), 0 - none, -1 - half of BB */   // Stop loss (в пунктах), 0 - отсутствует, -1 - половина BB
input int                  InpTakeProfit     =  -1;                  /* Take profit (in points), 0 - none, -1 - ATR value */  // Take profit (в пунктах), 0 - отсутствует, -1 - значение ATR
input double               InpSLMltp         =  2.6;                 /* Stop loss size multiplier, if SL==-1 */               // Множитель размера Stop loss, если Stop loss==-1
input double               InpTPMltp         =  1.3;                 /* Take profit size multiplier, if TP==-1 */             // Множитель размера Take profit, если Take profit==-1

//+------------------------------------------------------------------+
//| Глобальные переменные                                            |
//+------------------------------------------------------------------+
CTrade   trade;                                                      // Объект торгового класса
int      handle_wpr;                                                 // Хэндл индикатора WPR
int      handle_bb;                                                  // Хэндл индикатора BB
int      handle_atr;                                                 // Хэндл индикатора ATR
double   wpr[DATA_COUNT]={};                                         // Массив значений WPR
double   bb0[DATA_COUNT]={};                                         // Массив значений BB, буфер 0 (Upper)
double   bb1[DATA_COUNT]={};                                         // Массив значений BB, буфер 1 (Lower)
double   bb2[DATA_COUNT]={};                                         // Массив значений BB, буфер 2 (Middle)
double   atr[DATA_COUNT]={};                                         // Массив значений ATR
MqlRates prc[DATA_COUNT]={};                                         // Массив цен и времени

int      period_wpr;                                                 // Период расчёта WPR
double   overbought_wpr;                                             // Уровень перекеупленности WPR
double   oversold_wpr;                                               // Уровень перепроданности WPR

int      period_bb;                                                  // Период расчёта BB
double   deviation_bb;                                               // Отклонения BB
int      shift_bb;                                                   // Сдвиг BB

int      period_atr;                                                 // Период расчёта ATR

double   lot;                                                        // Объём позиции
string   program_name;                                               // Имя программы
int      prev_total;                                                 // Количество позиций на прошлой проверке
bool     netto;                                                      // Признак нетто-счёта

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- Если счёт не с типом хеджинг - ставим флаг и сообщаем о некорректной работе советника
   netto=false;
   if(AccountInfoInteger(ACCOUNT_MARGIN_MODE)!=ACCOUNT_MARGIN_MODE_RETAIL_HEDGING)
     {
      Print("The advisor is designed for use on a hedging account. Correct operation on a netting account is not guaranteed.");
      netto=true;
     }
   
//--- Устанавливаем и корректируем входные переменные индикаторов
//--- WPR
   period_wpr=(InpPeriodWPR<1 ? 14 : InpPeriodWPR);
   overbought_wpr=(InpOverboughtWPR<-99  ? -99  : InpOverboughtWPR> 0   ?  0  : InpOverboughtWPR);
   oversold_wpr  =(InpOversoldWPR  <-100 ? -100 : InpOversoldWPR  >-1   ? -1  : InpOversoldWPR);
   if(overbought_wpr<=oversold_wpr)
      overbought_wpr+=1;
//--- BB
   period_bb=(InpPeriodBB<2 ? 20 : InpPeriodBB);
   deviation_bb=InpDeviationBB;
   shift_bb=InpShiftBB;
//--- ATR
   period_atr=(InpPeriodATR<1 ? 14 : InpPeriodATR);
   
//--- Инициализируем массивы значений индикаторов
   ArrayInitialize(wpr,EMPTY_VALUE);
   ArrayInitialize(bb0,EMPTY_VALUE);
   ArrayInitialize(bb1,EMPTY_VALUE);
   ArrayInitialize(bb2,EMPTY_VALUE);
   ZeroMemory(prc);

//--- Создаём хэндлы индикаторов
//--- WPR
   handle_wpr=iWPR(Symbol(),PERIOD_CURRENT,period_wpr);
   if(handle_wpr==INVALID_HANDLE)
     {
      PrintFormat("%s: Failed to create iWPR(%d) handle",__FUNCTION__,period_wpr);
      return INIT_FAILED;
     }
//--- BB
   handle_bb=iBands(Symbol(),PERIOD_CURRENT,period_bb,shift_bb,deviation_bb,InpPriceBB);
   if(handle_bb==INVALID_HANDLE)
     {
      PrintFormat("%s: Failed to create iBands(%d,%d,%.3f,%s) handle",__FUNCTION__,period_bb,shift_bb,deviation_bb,EnumToString(InpPriceBB));
      return INIT_FAILED;
     }
//--- WPR
   handle_atr=iATR(Symbol(),PERIOD_CURRENT,period_atr);
   if(handle_atr==INVALID_HANDLE)
     {
      PrintFormat("%s: Failed to create iATR(%d) handle",__FUNCTION__,period_atr);
      return INIT_FAILED;
     }

//--- Имя программы и количество позиций на прошлой проверке
   program_name=MQLInfoString(MQL_PROGRAM_NAME);
   prev_total=0;
   
//--- Автоматическая установка типа заполнения
   trade.SetTypeFilling(GetTypeFilling());
//--- Установка магика
   trade.SetExpertMagicNumber(InpMagic);
//--- Установка проскальзывания
   trade.SetDeviationInPoints(InpDeviation);
//--- Установка лота с корректировкой введённого значения
   lot=CorrectLots(InpVolume);
   
//--- Всё успешно
   PrintFormat("%s::%s: Initialization was successful",program_name,__FUNCTION__);
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//--- Получаем в массивы данные трёх баров индикаторов и цен
   if(!CopyIndicatorsData() || !CopyPricesData())
      return;
   
//--- Заполнение списков тикетов позиций
   int positions_total=PositionsTotal();
   if(prev_total!=positions_total)
     {
      if(!FillingListTickets(Symbol(),InpMagic))
         return;
      prev_total=positions_total;
     }
   
//--- Получаем сигналы от индикаторов
   ENUM_SIGNAL_TYPE signal_wpr=SignalWPR();
   ENUM_SIGNAL_TYPE signal_bb=SignalBB();
//--- Общий сигнал
   ENUM_SIGNAL_TYPE signal=(signal_wpr==signal_bb ? signal_wpr : SIGNAL_TYPE_NONE);
   
//--- Если не торгуем - ставим метки сигналов индикаторов
   if(InpSignalsOnly)
     {
      SetArrow(IND_WPR,signal_wpr,false);
      SetArrow(IND_BANDS,signal_bb,true);
      return;
     }
     
//--- Торгуем по сигналам
   TradeProcess(signal);
  }
//+------------------------------------------------------------------+
//| Получает значения Open для трёх баров                            |
//+------------------------------------------------------------------+
bool CopyPricesData(void)
  {
   ResetLastError();
   if(CopyRates(Symbol(),PERIOD_CURRENT,0,DATA_COUNT,prc)!=DATA_COUNT)
     {
      PrintFormat("%s: Failed to get price Open data. Error %d",__FUNCTION__,GetLastError());
      return false;
     }
   return true;
  }
//+------------------------------------------------------------------+
//| Получает значения WPR для трёх баров                             |
//+------------------------------------------------------------------+
bool CopyWPRData(void)
  {
   ResetLastError();
   if(CopyBuffer(handle_wpr,0,0,DATA_COUNT,wpr)!=DATA_COUNT)
     {
      PrintFormat("%s: Failed to get WPR data. Error %d",__FUNCTION__,GetLastError());
      return false;
     }
   return true;
  }
//+------------------------------------------------------------------+
//| Получает значения BB для трёх баров                              |
//+------------------------------------------------------------------+
bool CopyBBData(void)
  {
   ResetLastError();
   if(CopyBuffer(handle_bb,UPPER_BAND,0,DATA_COUNT,bb0)!=DATA_COUNT)
     {
      PrintFormat("%s: Failed to get BB Upper Line data. Error %d",__FUNCTION__,GetLastError());
      return false;
     }
   if(CopyBuffer(handle_bb,LOWER_BAND,0,DATA_COUNT,bb1)!=DATA_COUNT)
     {
      PrintFormat("%s: Failed to get BB Lower Line data. Error %d",__FUNCTION__,GetLastError());
      return false;
     }
   if(CopyBuffer(handle_bb,BASE_LINE,0,DATA_COUNT,bb2)!=DATA_COUNT)
     {
      PrintFormat("%s: Failed to get BB Base Line data. Error %d",__FUNCTION__,GetLastError());
      return false;
     }
   return true;
  }
//+------------------------------------------------------------------+
//| Получает значения ATR для трёх баров                             |
//+------------------------------------------------------------------+
bool CopyATRData(void)
  {
   ResetLastError();
   if(CopyBuffer(handle_atr,0,0,DATA_COUNT,atr)!=DATA_COUNT)
     {
      PrintFormat("%s: Failed to get ATR data. Error %d",__FUNCTION__,GetLastError());
      return false;
     }
   return true;
  }
//+------------------------------------------------------------------+
//| Получает значения индикаторов для трёх баров                     |
//+------------------------------------------------------------------+
bool CopyIndicatorsData(void)
  {
   bool res=CopyWPRData(); // Результат получения данных WPR
   res &=CopyBBData();     // Результат получения данных BB
   res &=CopyATRData();    // Результат получения данных ATR
   return res;
  }
//+------------------------------------------------------------------+
//| Возвращает из массива цену Open по индексу таймсерии (0 - 2)     |
//+------------------------------------------------------------------+
double PriceOpen(const int index)
  {
   return(index<0 || index>DATA_COUNT-1 ? 0 : prc[DATA_COUNT-index-1].open);
  }
//+------------------------------------------------------------------+
//|Возвращает из массива цену High по индексу таймсерии (0 - 2)|
//+------------------------------------------------------------------+
double PriceHigh(const int index)
  {
   return(index<0 || index>DATA_COUNT-1 ? 0 : prc[DATA_COUNT-index-1].high);
  }
//+------------------------------------------------------------------+
//| Возвращает из массива цену Low по индексу таймсерии (0 - 2)      |
//+------------------------------------------------------------------+
double PriceLow(const int index)
  {
   return(index<0 || index>DATA_COUNT-1 ? 0 : prc[DATA_COUNT-index-1].low);
  }
//+------------------------------------------------------------------+
//| Возвращает из массива цену Close по индексу таймсерии (0 - 2)    |
//+------------------------------------------------------------------+
double PriceClose(const int index)
  {
   return(index<0 || index>DATA_COUNT-1 ? 0 : prc[DATA_COUNT-index-1].close);
  }
//+------------------------------------------------------------------+
//| Возвращает из массива время бара по индексу таймсерии (0 - 2)    |
//+------------------------------------------------------------------+
datetime Time(const int index)
  {
   return(index<0 || index>DATA_COUNT-1 ? 0 : prc[DATA_COUNT-index-1].time);
  }
//+------------------------------------------------------------------+
//| Возвращает из массива данные WPR по индексу таймсерии (0 - 2)    |
//+------------------------------------------------------------------+
double WPR(const int index)
  {
   return(index<0 || index>DATA_COUNT-1 ? EMPTY_VALUE : wpr[DATA_COUNT-index-1]);
  }
//+------------------------------------------------------------------+
//|Возвращает из массива данные BB Upper по индексу таймсерии (0 - 2)|
//+------------------------------------------------------------------+
double BBUpper(const int index)
  {
   return(index<0 || index>DATA_COUNT-1 ? EMPTY_VALUE : bb0[DATA_COUNT-index-1]);
  }
//+------------------------------------------------------------------+
//|Возвращает из массива данные BB Lower по индексу таймсерии (0 - 2)|
//+------------------------------------------------------------------+
double BBLower(const int index)
  {
   return(index<0 || index>DATA_COUNT-1 ? EMPTY_VALUE : bb1[DATA_COUNT-index-1]);
  }
//+-------------------------------------------------------------------+
//|Возвращает из массива данные BB Middle по индексу таймсерии (0 - 2)|
//+-------------------------------------------------------------------+
double BBMiddle(const int index)
  {
   return(index<0 || index>DATA_COUNT-1 ? EMPTY_VALUE : bb2[DATA_COUNT-index-1]);
  }
//+------------------------------------------------------------------+
//| Возвращает половину ширины BB в пунктах                          |
//+------------------------------------------------------------------+
int HalfSizeBB(const int index)
  {
   double up=BBUpper(index);
   double dn=BBLower(index);
   if(up==EMPTY_VALUE || dn==EMPTY_VALUE)
      return 0;
   return (int)round(((up-dn)/2.0)/Point());
  }
//+------------------------------------------------------------------+
//| Возвращает из массива данные ATR по индексу таймсерии (0 - 2)    |
//+------------------------------------------------------------------+
double ATR(const int index)
  {
   return(index<0 || index>DATA_COUNT-1 ? EMPTY_VALUE : atr[DATA_COUNT-index-1]);
  }
//+------------------------------------------------------------------+
//| Сигнал WPR                                                       |
//+------------------------------------------------------------------+
ENUM_SIGNAL_TYPE SignalWPR(void)
  {
//--- Получаем цены WPR
   double wpr0=WPR(1);
   double wpr1=WPR(2);
//--- Ошибка - нет сигнала
   if(wpr0==EMPTY_VALUE || wpr1==EMPTY_VALUE)
      return SIGNAL_TYPE_NONE;
      
//--- Сигнал на покупку
   if(wpr0>wpr1 && wpr1<=oversold_wpr)
      return SIGNAL_TYPE_LONG;
//--- Сигнал на продажу
   if(wpr0<wpr1 && wpr1>=overbought_wpr)
      return SIGNAL_TYPE_SHORT;
//--- Нет сигнала
   return SIGNAL_TYPE_NONE;
  }
//+------------------------------------------------------------------+
//| Сигнал BB                                                        |
//+------------------------------------------------------------------+
ENUM_SIGNAL_TYPE SignalBB(void)
  {
//--- Получаем цены BB и Open
   double bbup=BBUpper(0);
   double bbdn=BBLower(0);
   double bbmd=BBMiddle(0);
   double price=PriceOpen(0);
//--- Ошибка - нет сигнала
   if(bbup==EMPTY_VALUE || bbdn==EMPTY_VALUE || bbmd==EMPTY_VALUE || price==0)
      return SIGNAL_TYPE_NONE;
   
//--- Средние цены выше и ниже средней линии
   double upper=(bbup+bbmd)*0.5;
   double lower=(bbdn+bbmd)*0.5;
   
//--- Сигнал в лонг
   if(price<lower)
      return SIGNAL_TYPE_LONG;
//--- Сигнал в шорт
   if(price>upper)
      return SIGNAL_TYPE_SHORT;
//--- Нет сигнала
   return SIGNAL_TYPE_NONE;
  }
//+------------------------------------------------------------------+
//| Ставит сигнальные значки на графике                              |
//+------------------------------------------------------------------+
void SetArrow(const ENUM_INDICATOR indicator,const ENUM_SIGNAL_TYPE signal,bool chart_redraw)
  {
//--- Если нет сигнала, или передан не верный тип индикатора - уходим
   if(signal==SIGNAL_TYPE_NONE || (indicator!=IND_WPR && indicator!=IND_BANDS))
      return;
   
//--- Получаем время открытия текущего бара
   datetime time=Time(0);
   if(time==0)
      return;

   ENUM_OBJECT obj_type;   // Тип объекта
   double      price=0;    // Цена установки значка
//--- В зависимости от типа индикатора устанавливаем цену и тип значка
   switch(indicator)
     {
      //--- WPR
      case IND_WPR :
        price=PriceOpen(0);
        obj_type=(signal==SIGNAL_TYPE_LONG ? OBJ_ARROW_BUY : OBJ_ARROW_SELL);
        break;
      
      //--- BB
      default:
        obj_type=OBJ_ARROW;
        price=(signal==SIGNAL_TYPE_LONG ? BBLower(0) : BBUpper(0));
        break;
     }
//--- Если время получить не удалось - уходим
   if(price==0)
      return;
   
//--- Создаём имя объекта
   string ind=(indicator==IND_WPR ? "_WPR" : "_BB");
   string sig=(signal==SIGNAL_TYPE_LONG ? "_Long_signal_" : "_Short_signal_");
   string name=program_name+ind+sig+TimeToString(time);
//--- Если объект с таким именем уже есть - уходим
   if(ObjectFind(0,name)==0)
      return;
      
//--- Создаём объект
   if(!ObjectCreate(0,name,obj_type,0,time,price))
      return;
   
//--- установим цвет знака
   ObjectSetInteger(0,name,OBJPROP_COLOR,(signal==SIGNAL_TYPE_LONG ? clrBlue : clrRed));
//--- установим стиль линии (при выделении)
   ObjectSetInteger(0,name,OBJPROP_STYLE,STYLE_SOLID);
//--- установим размер линии (при выделении)
   ObjectSetInteger(0,name,OBJPROP_WIDTH,0);
   
//--- установим код стрелки для сигнала BB
   if(indicator==IND_BANDS)
      ObjectSetInteger(0,name,OBJPROP_ARROWCODE,159);
   
//--- отобразим на переднем (false) или заднем (true) плане
   ObjectSetInteger(0,name,OBJPROP_BACK,false);
//--- отключим режим выделения и перемещения знака мышью
   ObjectSetInteger(0,name,OBJPROP_SELECTABLE,false);
   ObjectSetInteger(0,name,OBJPROP_SELECTED,false);
//--- скроем имя графического объекта в списке объектов
   ObjectSetInteger(0,name,OBJPROP_HIDDEN,true);
   
//--- Перерисовываем график
   if(chart_redraw)
      ChartRedraw();
  }
//+------------------------------------------------------------------+
//| Возвращает тип исполнения ордера, равный type,                   |
//| если он доступен на символе, иначе - корректный вариант          |
//| https://www.mql5.com/ru/forum/170952/page4#comment_4128864       |
//+------------------------------------------------------------------+
ENUM_ORDER_TYPE_FILLING GetTypeFilling(const ENUM_ORDER_TYPE_FILLING type=ORDER_FILLING_RETURN)
  {
   const ENUM_SYMBOL_TRADE_EXECUTION exe_mode=(ENUM_SYMBOL_TRADE_EXECUTION)::SymbolInfoInteger(Symbol(),SYMBOL_TRADE_EXEMODE);
   const int filling_mode=(int)::SymbolInfoInteger(Symbol(),SYMBOL_FILLING_MODE);

   return((filling_mode==0 || (type>=ORDER_FILLING_RETURN) || ((filling_mode &(type+1))!=type+1)) ?
          (((exe_mode==SYMBOL_TRADE_EXECUTION_EXCHANGE) || (exe_mode==SYMBOL_TRADE_EXECUTION_INSTANT)) ?
          ORDER_FILLING_RETURN :((filling_mode==SYMBOL_FILLING_IOC) ? ORDER_FILLING_IOC : ORDER_FILLING_FOK)) : type);
  }
//+------------------------------------------------------------------+
//| Возвращает корректный лот                                        |
//+------------------------------------------------------------------+
double CorrectLots(const double lots,const bool to_min_correct=true)
  {
   double min=SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_MIN);
   double max=SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_MAX);
   double step=SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_STEP);
   return(to_min_correct ? VolumeRoundToSmaller(lots,min,max,step) : VolumeRoundToCorrect(lots,min,max,step));
  }
//+------------------------------------------------------------------+
//| Возвращает ближайший корректный лот                              |
//+------------------------------------------------------------------+
double VolumeRoundToCorrect(const double volume,const double min,const double max,const double step)
  {
   return(step==0 ? min : fmin(fmax(round(volume/step)*step,min),max));
  }
//+------------------------------------------------------------------+
//| Возвращает ближайший в меньшую сторону корректный лот            |
//+------------------------------------------------------------------+
double VolumeRoundToSmaller(const double volume,const double min,const double max,const double step)
  {
   return(step==0 ? min : fmin(fmax(floor(volume/step)*step,min),max));
  }
//+------------------------------------------------------------------+
//| Возвращает флаг не превышения общего объёма на счёте             |
//+------------------------------------------------------------------+
bool CheckLotForLimitAccount(const ENUM_POSITION_TYPE position_type,const double volume)
  {
   double lots_limit=SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_LIMIT);
   if(lots_limit==0)
      return true;
   double total_volume=(position_type==POSITION_TYPE_BUY ? Data.Buy.total_volume : Data.Sell.total_volume);
   return(total_volume+volume<=lots_limit);
  }
//+------------------------------------------------------------------+
//| Возвращает корректный StopLoss относительно StopLevel            |
//+------------------------------------------------------------------+
double CorrectStopLoss(const ENUM_POSITION_TYPE position_type,const int stop_loss)
  {
   if(stop_loss==0)
      return 0;
   double pt=Point();
   double price=(position_type==POSITION_TYPE_BUY ? SymbolInfoDouble(Symbol(),SYMBOL_ASK) : SymbolInfoDouble(Symbol(),SYMBOL_BID));
   int lv=StopLevel(), dg=Digits();
   return(position_type==POSITION_TYPE_BUY   ?  NormalizeDouble(fmin(price-lv*pt,price-stop_loss*pt),dg) :
                                                NormalizeDouble(fmax(price+lv*pt,price+stop_loss*pt),dg));
  }
//+------------------------------------------------------------------+
//| Возвращает корректный TakeProfit относительно StopLevel          |
//+------------------------------------------------------------------+
double CorrectTakeProfit(const ENUM_POSITION_TYPE position_type,const int take_profit)
  {
   if(take_profit==0)
      return 0;
   double pt=Point();
   double price=(position_type==POSITION_TYPE_BUY ? SymbolInfoDouble(Symbol(),SYMBOL_ASK) : SymbolInfoDouble(Symbol(),SYMBOL_BID));
   int lv=StopLevel(), dg=Digits();
   return(position_type==POSITION_TYPE_BUY   ?  NormalizeDouble(fmax(price+lv*pt,price+take_profit*pt),dg) :
                                                NormalizeDouble(fmin(price-lv*pt,price-take_profit*pt),dg));
  }
//+------------------------------------------------------------------+
//| Возвращает рассчитанный StopLevel                                |
//+------------------------------------------------------------------+
int StopLevel(void)
  {
   int sp=(int)SymbolInfoInteger(Symbol(),SYMBOL_SPREAD);
   int lv=(int)SymbolInfoInteger(Symbol(),SYMBOL_TRADE_STOPS_LEVEL);
   return(lv==0 ? sp*SPREAD_MLTP : lv);
  }
//+------------------------------------------------------------------+
//| Возвращает "неопределённое" состояние торгового окружения        |
//+------------------------------------------------------------------+
bool IsUncertainStateEnv(const string symbol_name,const ulong magic_number)
  {
//--- В тестере сосотояние окружения всегда корректно
   if(MQLInfoInteger(MQL_TESTER))
      return false;
//--- В цикле по количеству ордеров
   int total=OrdersTotal();
   for(int i=total-1; i>=0; i--)
     {
      //--- выбираем ордер для получения его свойств
      if(OrderGetTicket(i)==0)
         continue;
      //--- если магик ордера не соответствует искомому - пропускаем
      if(OrderGetInteger(ORDER_MAGIC)!=magic_number)
         continue;
      //--- если тип ордера не Buy и не Sell - пропускаем
      ENUM_ORDER_TYPE type=(ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
      if(type!=ORDER_TYPE_BUY && type!=ORDER_TYPE_SELL)
         continue;
      //--- если символ ордера соответствует искомому, но в ордере нет записи об идентификаторе позиции,
      //--- значит данные об открывающейся позиции ещё не добавлены в историю ордеров.
      //--- Это неопределённое состояние окружения - возвращаем true
      if(!OrderGetInteger(ORDER_POSITION_ID) && OrderGetString(ORDER_SYMBOL)==symbol_name)
         return true;
     }
//--- Окружение в порядке
   return false;
  }
//+------------------------------------------------------------------+
//| Проверка состояния окружения                                     |
//+------------------------------------------------------------------+
bool CheckUncertainStateEnv(const string symbol_name,const ulong magic_number,const int attempts,const int wait)
  {
//--- Если окружение в порядке - возвращаем true
   if(IsUncertainStateEnv(symbol_name,magic_number))
      return true;
//--- Делаем цикле ENV_ATTEMPTS попыток получения корректного окружения с ожиданием ENV_WAIT_ATTEMPT между попытками
   int n=0;
   while(!IsStopped() && n<attempts && IsUncertainStateEnv(symbol_name,magic_number))
     {
      n++;
      Sleep(wait);
     }
//--- Если по завершении ожидания окружение всё ещё неопределённое - сообщаем об этом и возвращаем false
   if(n>=attempts && IsUncertainStateEnv(symbol_name,magic_number))
     {
      PrintFormat("%s: Uncertain state of the environment. Please try again.",__FUNCTION__);
      return false;
     }
//--- Окружение корректно
   return true;
  }
//+------------------------------------------------------------------+
//| Заполняет массивы тикетов позиций                                |
//+------------------------------------------------------------------+
bool FillingListTickets(const string symbol_name,const ulong magic_number)
  {
//--- Если торговое окружение не корректно - возвращаем false
   if(!CheckUncertainStateEnv(symbol_name,magic_number,ENV_ATTEMPTS,ENV_WAIT_ATTEMPT))
      return false;

//--- Очищаем списки и инициализируем переменные
   Data.Buy.list_tickets.Clear();
   Data.Sell.list_tickets.Clear();
   Data.Buy.total_volume=0;
   Data.Sell.total_volume=0;
   
//--- В цикле по открытым позициям
   int total=PositionsTotal();
   for(int i=total-1; i>WRONG_VALUE; i--)
     {
      //--- выбираем позицию для получения свойств
      ulong ticket=PositionGetTicket(i);
      if(ticket==0)
         continue;
      //--- Если магик или символ не соответствуют переданным в функцию - идём дальше
      if(PositionGetInteger(POSITION_MAGIC)!=InpMagic || PositionGetString(POSITION_SYMBOL)!=symbol_name)
         continue;
      //--- Получаем тип и объём позиции
      ENUM_POSITION_TYPE type=(ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      double volume=PositionGetDouble(POSITION_VOLUME);
      //--- В зависимости от типа позиции добавляем тикет и объём в соответствующие списки
      if(type==POSITION_TYPE_BUY)
        {
         Data.Buy.list_tickets.Add(ticket);
         Data.Buy.total_volume+=volume;
        }
      //--- POSITION_TYPE_SELL
      else
        {
         Data.Sell.list_tickets.Add(ticket);
         Data.Sell.total_volume+=volume;
        }
     }
//--- Всё успешно
   return true;
  }
//+------------------------------------------------------------------+
//| Возвращает количество позиций Buy                                |
//+------------------------------------------------------------------+
int TotalBuy(void)
  {
   return Data.Buy.list_tickets.Total();
  }
//+------------------------------------------------------------------+
//| Возвращает количество позиций Sell                               |
//+------------------------------------------------------------------+
int TotalSell(void)
  {
   return Data.Sell.list_tickets.Total();
  }
//+------------------------------------------------------------------+
//| Возвращает последний добавленный тикет позиции по типу           |
//+------------------------------------------------------------------+
ulong LastAddedTicket(const ENUM_POSITION_TYPE type)
  {
   return(type==POSITION_TYPE_BUY ? (TotalBuy()>0 ? Data.Buy.list_tickets.At(0) : 0) : (TotalSell()>0 ? Data.Sell.list_tickets.At(0) : 0));
  }
//+------------------------------------------------------------------+
//| Возвращает номер бара, на котором была открыта позиция           |
//+------------------------------------------------------------------+
int PositionBar(const ulong ticket)
  {
//--- Выбираем позицию по тикету
   ResetLastError();
   if(!PositionSelectByTicket(ticket))
     {
      PrintFormat("%s: Failed to select position by ticket #%I64u. Error %d",__FUNCTION__,ticket,GetLastError());
      return -1;
     }
//--- Получаем время открытия и символ позиции
   datetime time=(datetime)PositionGetInteger(POSITION_TIME);
   string   symbol=PositionGetString(POSITION_SYMBOL);
   
//--- Возвращаем номер бара по времени открытия позиции
   return iBarShift(symbol,PERIOD_CURRENT,time);
  }
//+------------------------------------------------------------------+
//| Возвращает наличие указанной позиции, открытой на текущем баре   |
//+------------------------------------------------------------------+
bool IsPresentPosOnCurrentBar(const ENUM_POSITION_TYPE type)
  {
   ulong ticket=LastAddedTicket(type);
   return(ticket>0 ? PositionBar(ticket)==0 : false);
  }
//+------------------------------------------------------------------+
//| Возвращает цену открытия позиции по тикету                       |
//+------------------------------------------------------------------+
double PositionPriceOpen(const ulong ticket)
  {
//--- Проверяем тикет
   if(ticket==0)
      return 0;
//--- Выбираем позицию по тикету
   ResetLastError();
   if(!PositionSelectByTicket(ticket))
     {
      PrintFormat("%s: Failed to select position by ticket #%I64u. Error %d",__FUNCTION__,ticket,GetLastError());
      return 0;
     }
//--- Возвращаем цену открытия позиции
   return PositionGetDouble(POSITION_PRICE_OPEN);
  }
//+------------------------------------------------------------------+
//| Закрывает позиции Buy                                            |
//+------------------------------------------------------------------+
bool CloseBuy(void)
  {
   int total=TotalBuy();
   bool res=true;
   for(int i=total-1; i>=0; i--)
     {
      ulong ticket=Data.Buy.list_tickets.At(i);
      if(ticket==NULL)
         continue;
      if(!trade.PositionClose(ticket,InpDeviation))
         res=false;
     }
   return res;
  }
//+------------------------------------------------------------------+
//| Закрывает позиции Sell                                           |
//+------------------------------------------------------------------+
bool CloseSell(void)
  {
   int total=TotalSell();
   bool res=true;
   for(int i=total-1; i>=0; i--)
     {
      ulong ticket=Data.Sell.list_tickets.At(i);
      if(ticket==NULL)
         continue;
      if(!trade.PositionClose(ticket,InpDeviation))
         res=false;
     }
   return res;
  }
//+------------------------------------------------------------------+
//| Открытие позиции                                                 |
//+------------------------------------------------------------------+
bool OpenPosition(const string symbol_name,const ENUM_POSITION_TYPE type,const double volume,const string comment)
  {
//--- Рассчитываем значения для стоп-приказов
   int    bb=int(HalfSizeBB(0)*InpSLMltp);
   double atrd=ATR(0);
   int    atrp=(atrd!=EMPTY_VALUE ? int(round(atrd*InpTPMltp/Point())) : 0);
   double sl=(InpStopLoss==0   ? 0 : (InpStopLoss<0 ? (bb!=0   ? CorrectStopLoss(type,bb)     : 0) : CorrectStopLoss(type,InpStopLoss)));
   double tp=(InpTakeProfit==0 ? 0 : (InpStopLoss<0 ? (atrp!=0 ? CorrectTakeProfit(type,atrp) : 0) : CorrectTakeProfit(type,InpTakeProfit)));

//--- На неттинговом счёте убираем стоп-приказы
   if(netto)
      sl=tp=0;

//--- Получаем цены
   MqlTick tick={};
   if(!SymbolInfoTick(symbol_name,tick))
     {
      PrintFormat("%s: Unable to get prices");
      return false;
     }
//--- Проверяем и получаем нормализованный лот открываемой позиции
   double ll=trade.CheckVolume(symbol_name,volume,(type==POSITION_TYPE_BUY ? tick.ask : tick.bid),(ENUM_ORDER_TYPE)type);
   if(ll==0)
     {
      PrintFormat("%s: Error. CheckVolume() returned a zero lot",__FUNCTION__);
      return false;
     }

//--- Проверяем ограничение на максимальный объём открытых позиций на счёте
   if(!CheckLotForLimitAccount(type,ll))
     {
      PrintFormat("%s: CheckLotForLimitAccount() returned an error",__FUNCTION__);
      return false;
     }

//--- Может быть ситуация, когда торговый приказ уже был отправлен, но он ещё не полностью обработан,
//--- что может привести к задвоению открываемой позиции.
//--- Если торговое окружение не корректно - возвращаем false
   if(!CheckUncertainStateEnv(symbol_name,InpMagic,ENV_ATTEMPTS,ENV_WAIT_ATTEMPT))
      return false;

//--- Ожидание получения корректного торгового окружения может занять некоторое время
//--- Ещё раз получим цены
   if(!SymbolInfoTick(symbol_name,tick))
     {
      PrintFormat("%s: Unable to get prices");
      return false;
     }

//--- Возвращаем результат отправки торгового запроса на сервер
   return(type==POSITION_TYPE_BUY ? trade.Buy(ll,symbol_name,tick.ask,sl,tp,comment) : trade.Sell(ll,symbol_name,tick.bid,sl,tp,comment));
  }
//+------------------------------------------------------------------+
//| Процесс торговли                                                 |
//+------------------------------------------------------------------+
void TradeProcess(const ENUM_SIGNAL_TYPE signal)
  {
//--- Нет сигнала - уходим
   if(signal==SIGNAL_TYPE_NONE)
      return;
   
//--- Сигнал на покупку
   if(signal==SIGNAL_TYPE_LONG)
     {
      //--- Если нет открытой позиции Buy на этом баре
      if(!IsPresentPosOnCurrentBar(POSITION_TYPE_BUY))
        {
         //--- Получаем цену последней открытой позиции Buy
         double price_last=PositionPriceOpen(LastAddedTicket(POSITION_TYPE_BUY));
         //--- Если это самая первая позиция Buy, либо цена открытия лучше цены открытия прошлой позиции -
         //--- отсылаем запрос на открытие позиции Buy
         if(price_last==0 || price_last>SymbolInfoDouble(Symbol(),SYMBOL_ASK))
           {
            //--- Если позиция открыта - обновляем списки тикетов открытых позиций
            if(OpenPosition(Symbol(),POSITION_TYPE_BUY,lot,""))
               FillingListTickets(Symbol(),InpMagic);
           }
        }
     }
   
//--- Сигнал на продажу
   if(signal==SIGNAL_TYPE_SHORT)
     {
      //--- Если нет открытой позиции Sell на этом баре
      if(!IsPresentPosOnCurrentBar(POSITION_TYPE_SELL))
        {
         //--- Получаем цену последней открытой позиции Sell
         double price_last=PositionPriceOpen(LastAddedTicket(POSITION_TYPE_SELL));
         //--- Если это самая первая позиция Sell, либо цена открытия лучше цены открытия прошлой позиции -
         //--- отсылаем запрос на открытие позиции Sell
         if(price_last<SymbolInfoDouble(Symbol(),SYMBOL_ASK))
           {
            //--- Если позиция открыта - обновляем списки тикетов открытых позиций
            if(OpenPosition(Symbol(),POSITION_TYPE_SELL,lot,""))
               FillingListTickets(Symbol(),InpMagic);
           }
        }
     }
  }
//+------------------------------------------------------------------+
